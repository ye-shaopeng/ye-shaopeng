/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  FileSuggest: () => FileSuggest,
  default: () => PinnedNotesPlugin,
  trimFile: () => trimFile
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// main.ts
var PinnedNote = class {
  constructor(title, path, icon) {
    this.id = v4_default();
    this.icon = icon;
    this.path = path;
    this.title = title;
  }
};
var DEFAULT_SETTINGS = {
  pinnedNotes: []
};
var PinnedNotesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async addPinnedNote(note) {
    this.settings.pinnedNotes.push(note);
    await this.saveSettings();
    await this.loadSettings();
  }
  async removePinnedNote(noteId) {
    const noteIndex = this.settings.pinnedNotes.findIndex((note) => note.id === noteId);
    delete this.settings.pinnedNotes[noteIndex];
    this.settings.pinnedNotes.splice(noteIndex, 1);
    await this.saveSettings();
    await this.loadSettings();
  }
  async loadSettings() {
    var _a;
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    (_a = this.ribbonIcons) == null ? void 0 : _a.forEach((ribbonIcon, index) => {
      ribbonIcon.remove();
      delete this.ribbonIcons[index];
    });
    this.ribbonIcons = this.settings.pinnedNotes.map(
      (note) => this.addRibbonIcon(
        note.icon === "" ? "file" : note.icon,
        note.title,
        async (e) => {
          await this.app.workspace.openLinkText(
            note.path,
            "",
            e.button == 1 || e.button == 2 || import_obsidian.Keymap.isModifier(e, "Mod")
          );
        }
      )
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let isCanBeAddedNewNote = true;
    let title = "";
    let path = "";
    let icon = "";
    let changedTitle;
    let changedPath;
    let changedIcon;
    const addNoteButton = new import_obsidian.Setting(containerEl).setName("Add pinned note").setDesc(`Provide: 1) file's name that will be displayed on hover 2) path to this file, e.g Folder1/File1 3) Icon name from lucide.dev; if icon won't be provided, default icon "file" will be placed instead. RESTART OBSIDIAN AFTER CHANGES`);
    isCanBeAddedNewNote && addNoteButton.addButton((button) => {
      button.setIcon("plus").onClick(
        () => {
          isCanBeAddedNewNote = false;
          this.display();
          new import_obsidian.Setting(containerEl).setName("File").addText(
            (text) => text.setPlaceholder("Title").onChange((value) => title = value)
          ).addText(
            (text) => {
              new FileSuggest(this.app, text.inputEl);
              text.setPlaceholder("Path").onChange((value) => path = value);
            }
          ).addText(
            (text) => text.setPlaceholder("Icon(optional)").onChange((value) => icon = value)
          ).addButton((button2) => button2.setIcon("save").onClick(
            async () => {
              if (title.length !== 0 && path.length !== 0) {
                await this.plugin.addPinnedNote(new PinnedNote(title, path, icon));
                isCanBeAddedNewNote = true;
                this.display();
              } else {
                new import_obsidian.Notice("Provide title and path");
              }
            }
          ));
        }
      );
    });
    this.plugin.settings.pinnedNotes.forEach((note, index) => {
      new import_obsidian.Setting(containerEl).setName("File " + (index + 1)).addText(
        (text) => text.setPlaceholder("Title").setValue(note.title).onChange(async (value) => {
          changedTitle = value;
        })
      ).addText(
        (text) => {
          new FileSuggest(this.app, text.inputEl);
          text.setPlaceholder("Path").setValue(note.path).onChange(async (value) => {
            changedPath = value;
          });
        }
      ).addText(
        (text) => text.setPlaceholder("Icon(optional)").setValue(note.icon).onChange(async (value) => {
          changedIcon = value;
        })
      ).addButton(
        (button) => button.setIcon("save").onClick(
          async () => {
            if ((changedTitle === void 0 || changedTitle === note.title) && (changedPath === void 0 || changedPath === note.path) && (changedIcon === void 0 || changedIcon === note.icon)) {
              new import_obsidian.Notice("Provide any data");
              return;
            }
            if (changedTitle !== void 0) {
              if (changedTitle.length !== 0) {
                note.title = changedTitle;
                changedTitle = void 0;
              } else
                new import_obsidian.Notice("Provide title");
            }
            if (changedPath !== void 0) {
              if (changedPath.length !== 0) {
                note.path = changedPath;
                changedPath = void 0;
              } else
                new import_obsidian.Notice("Provide path");
            }
            if (changedIcon !== void 0) {
              note.icon = changedIcon;
              changedIcon = void 0;
            }
            await this.plugin.saveSettings();
            await this.plugin.loadSettings();
            this.display();
          }
        )
      ).addButton((button) => button.setIcon("trash-2").setWarning().onClick(
        async () => {
          await this.plugin.removePinnedNote(note.id);
          this.display();
        }
      ));
    });
  }
};
var FileSuggest = class extends import_obsidian.AbstractInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const files = [];
    const inputLower = inputStr.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian.TFile && ["md", "canvas"].contains(file.extension) && file.path.toLowerCase().contains(inputLower)) {
        files.push(file);
      }
    });
    return files;
  }
  renderSuggestion(file, el) {
    if (file.extension == "md") {
      el.setText(trimFile(file));
    } else {
      el.setText(file.path.slice(0, -7));
      el.insertAdjacentHTML(
        "beforeend",
        `<div class="nav-file-tag" style="display:inline-block;vertical-align:middle">canvas</div>`
      );
    }
  }
  selectSuggestion(file) {
    this.textInputEl.value = trimFile(file);
    this.textInputEl.trigger("input");
    this.close();
  }
};
function trimFile(file) {
  if (!file)
    return "";
  return file.extension == "md" ? file.path.slice(0, -3) : file.path;
}


/* nosourcemap */